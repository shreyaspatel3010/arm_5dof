#!/usr/bin/env python3

# Combined single-file module generated by request:
#   - ee_target_marker.py
#   - ik_node.py
#   - ik_solver.py
#
# NOTE: Imports have been de-duplicated. Per-file __main__ blocks were removed;
#       if ik_node.py had a __main__ block, it is appended at the end.

import math, numpy as np
import math
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import PoseStamped
from visualization_msgs.msg import InteractiveMarker, InteractiveMarkerControl, Marker
from interactive_markers.interactive_marker_server import InteractiveMarkerServer
from std_msgs.msg import Float64
import numpy as np
from rclpy.executors import MultiThreadedExecutor

################################################################################
# BEGIN ik_solver.py
################################################################################

# Autogenerated 6D IK (position + orientation) using damped least squares
# Chain joints derived from URDF: ['arm_base_joint', 'arm_shoulder_joint', 'arm_elbow_joint', 'arm_wrist_joint', 'arm_gripper_base_joint']

CHAIN_JOINTS = ['arm_base_joint', 'arm_shoulder_joint', 'arm_elbow_joint', 'arm_wrist_joint', 'arm_gripper_base_joint']
JOINTS = {'arm_base_joint': {'lower': -3.14, 'upper': 3.14, 'axis': [0.0, 0.0, 1.0]}, 'arm_shoulder_joint': {'lower': -1.918, 'upper': 1.918, 'axis': [1.0, 0.0, 0.0]}, 'arm_elbow_joint': {'lower': -1.748, 'upper': 1.748, 'axis': [1.0, 0.0, 0.0]}, 'arm_wrist_joint': {'lower': -1.942, 'upper': 1.942, 'axis': [1.0, 0.0, 0.0]}, 'arm_gripper_base_joint': {'lower': -1.57, 'upper': 1.57, 'axis': [0.0, 0.0, 1.0]}}
ORIGINS = {'arm_base_joint': {'xyz': [0.0, 0.0, 0.0], 'rpy': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}, 'arm_shoulder_joint': {'xyz': [0.0, 0.0, 0.2104], 'rpy': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}, 'arm_elbow_joint': {'xyz': [0.0, 0.0, 0.4186], 'rpy': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}, 'arm_wrist_joint': {'xyz': [0.0, 0.0, 0.4159], 'rpy': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}, 'arm_gripper_base_joint': {'xyz': [0.05655, 0.0, 0.1025], 'rpy': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}}

def hat(v):
    return np.array([[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]])

def axis_angle_rot(axis, theta):
    axis = np.array(axis, dtype=float)
    n = np.linalg.norm(axis)
    if n < 1e-12:
        return np.eye(3)
    axis = axis / n
    K = hat(axis)
    return np.eye(3) + math.sin(theta)*K + (1-math.cos(theta))*(K@K)

def quat_to_rot(q):
    x,y,z,w = q
    # normalize
    n = math.sqrt(x*x+y*y+z*z+w*w)
    if n < 1e-12:
        return np.eye(3)
    x,y,z,w = x/n, y/n, z/n, w/n
    xx,yy,zz = x*x, y*y, z*z
    xy,xz,yz = x*y, x*z, y*z
    wx,wy,wz = w*x, w*y, w*z
    return np.array([
        [1-2*(yy+zz), 2*(xy - wz), 2*(xz + wy)],
        [2*(xy + wz), 1-2*(xx+zz), 2*(yz - wx)],
        [2*(xz - wy), 2*(yz + wx), 1-2*(xx+yy)]
    ])

def rot_log(R):
    # returns rotation vector (axis * angle)
    tr = (np.trace(R)-1)/2.0
    tr = max(min(tr, 1.0), -1.0)
    th = math.acos(tr)
    if th < 1e-9:
        return np.zeros(3)
    v = np.array([R[2,1]-R[1,2], R[0,2]-R[2,0], R[1,0]-R[0,1]])/(2*math.sin(th))
    return v*th

def rpy_to_rot(r,p,y):
    cr, sr = math.cos(r), math.sin(r)
    cp, sp = math.cos(p), math.sin(p)
    cy, sy = math.cos(y), math.sin(y)
    Rz = np.array([[cy,-sy,0],[sy,cy,0],[0,0,1]])
    Ry = np.array([[cp,0,sp],[0,1,0],[-sp,0,cp]])
    Rx = np.array([[1,0,0],[0,cr,-sr],[0,sr,cr]])
    return Rz @ Ry @ Rx

def fk(q):
    R = np.eye(3); p = np.zeros(3)
    for qi, name in zip(q, CHAIN_JOINTS):
        o = ORIGINS[name]
        p = p + R @ np.array(o["xyz"])
        R = R @ np.array(o["rpy"])
        j = JOINTS[name]
        if np.linalg.norm(j["axis"])>0:
            R = R @ axis_angle_rot(np.array(j["axis"]), qi)
    return R, p

def fk_pose(q):
    R,p = fk(q)
    return R, p

def jacobian_6d(q, eps=1e-6):
    # numeric 6xN jacobian [dp; dtheta]
    q = np.array(q, dtype=float)
    R0, p0 = fk_pose(q)
    J = np.zeros((6, len(q)))
    for i in range(len(q)):
        dq = q.copy(); dq[i] += eps
        R1, p1 = fk_pose(dq)
        dp = (p1 - p0)/eps
        dR = R1 @ R0.T
        dtheta = rot_log(dR)/eps
        J[:3,i] = dp
        J[3:,i] = dtheta
    return J

def clamp(q):
    out = []
    for qi, name in zip(q, CHAIN_JOINTS):
        lo, hi = JOINTS[name]["lower"], JOINTS[name]["upper"]
        if not np.isfinite(lo): lo = -1e6
        if not np.isfinite(hi): hi =  1e6
        out.append(min(max(qi, lo), hi))
    return np.array(out)

def ik_solve_se3(target_pos, target_quat, q0=None, iters=250, damping=1e-2, w_pos=1.0, w_rot=1.0, tol_pos=1e-4, tol_rot=1e-3):
    # target_quat = (x,y,z,w)
    q = np.zeros(len(CHAIN_JOINTS)) if q0 is None else np.array(q0, dtype=float).copy()
    Rd = quat_to_rot(target_quat)
    for _ in range(iters):
        R, p = fk_pose(q)
        # position error
        ep = target_pos - p
        # orientation error (rotation vector of Rd * R^T)
        eR = rot_log(Rd @ R.T)
        # weighted error
        e = np.concatenate([w_pos*ep, w_rot*eR])
        if np.linalg.norm(ep) < tol_pos and np.linalg.norm(eR) < tol_rot:
            break
        J = jacobian_6d(q)
        # weight rows
        W = np.diag([w_pos,w_pos,w_pos,w_rot,w_rot,w_rot])
        JW = W @ J
        eW = W @ e
        JT = JW.T
        dq = JT @ np.linalg.inv(JW@JT + (damping**2)*np.eye(6)) @ eW
        q = clamp(q + dq)
    Rf, pf = fk_pose(q)
    return q, pf, Rf

################################################################################
# END ik_solver.py
################################################################################


################################################################################
# BEGIN ee_target_marker.py
################################################################################

FRAME_ID = "base_link"
MARKER_NAME = "ee_target"
MARKER_SCALE = 0.20

def make_axis_marker(scale=0.2):
    def arrow(axis):
        m = Marker()
        m.type = Marker.ARROW
        m.scale.x = scale * 0.7
        m.scale.y = scale * 0.04
        m.scale.z = scale * 0.06
        if axis == 'x':
            m.color.r, m.color.g, m.color.b, m.color.a = 1.0, 0.2, 0.2, 0.9
            m.pose.orientation.w = 1.0
        elif axis == 'y':
            m.color.r, m.color.g, m.color.b, m.color.a = 0.2, 1.0, 0.2, 0.9
            m.pose.orientation.z = 0.7071
            m.pose.orientation.w = 0.7071
        else:
            m.color.r, m.color.g, m.color.b, m.color.a = 0.2, 0.6, 1.0, 0.9
            m.pose.orientation.y = -0.7071
            m.pose.orientation.w = 0.7071
        return m
    return [arrow('x'), arrow('y'), arrow('z')]

def add_6dof_controls(im: InteractiveMarker):
    for axis, ori in [('x',(1.0,0.0,0.0,1.0)),
                      ('y',(0.0,1.0,0.0,1.0)),
                      ('z',(0.0,0.0,1.0,1.0))]:
        ctrl = InteractiveMarkerControl()
        ctrl.orientation.x = float(ori[0]); ctrl.orientation.y = float(ori[1])
        ctrl.orientation.z = float(ori[2]); ctrl.orientation.w = float(ori[3])
        ctrl.name = f"rotate_{axis}"
        ctrl.interaction_mode = InteractiveMarkerControl.ROTATE_AXIS
        im.controls.append(ctrl)

        ctrl = InteractiveMarkerControl()
        ctrl.orientation.x = float(ori[0]); ctrl.orientation.y = float(ori[1])
        ctrl.orientation.z = float(ori[2]); ctrl.orientation.w = float(ori[3])
        ctrl.name = f"move_{axis}"
        ctrl.interaction_mode = InteractiveMarkerControl.MOVE_AXIS
        im.controls.append(ctrl)

def normalize_quat(x,y,z,w):
    n = math.sqrt(float(x)*float(x)+float(y)*float(y)+float(z)*float(z)+float(w)*float(w))
    if n < 1e-12: return 0.0,0.0,0.0,1.0
    return float(x)/n, float(y)/n, float(z)/n, float(w)/n

class EETargetMarker(Node):
    def __init__(self):
        super().__init__("ee_target_marker")
        self.pub = self.create_publisher(PoseStamped, "ee_target", 10)
        self.server = InteractiveMarkerServer(self, "ee_target_server")
        self.create_marker()
        self.get_logger().info("Interactive marker ready: drag/rotate in RViz to set /ee_target")

    def create_marker(self):
        im = InteractiveMarker()
        im.header.frame_id = FRAME_ID
        im.name = MARKER_NAME
        im.description = "EE Target"
        im.scale = float(MARKER_SCALE)

        ctrl = InteractiveMarkerControl()
        ctrl.always_visible = True
        for m in make_axis_marker(scale=MARKER_SCALE):
            ctrl.markers.append(m)
        im.controls.append(ctrl)

        add_6dof_controls(im)

        im.pose.position.x = 0.25
        im.pose.position.y = 0.0
        im.pose.position.z = 0.90
        im.pose.orientation.x = 0.0
        im.pose.orientation.y = 0.0
        im.pose.orientation.z = 0.0
        im.pose.orientation.w = 1.0

        self.server.insert(im)
        self.server.setCallback(MARKER_NAME, self.process_feedback)
        self.server.applyChanges()

    def process_feedback(self, fb):
        px,py,pz = float(fb.pose.position.x), float(fb.pose.position.y), float(fb.pose.position.z)
        qx,qy,qz,qw = normalize_quat(fb.pose.orientation.x, fb.pose.orientation.y,
                                     fb.pose.orientation.z, fb.pose.orientation.w)
        ps = PoseStamped()
        ps.header.frame_id = fb.header.frame_id or FRAME_ID
        ps.header.stamp = self.get_clock().now().to_msg()
        ps.pose.position.x = px; ps.pose.position.y = py; ps.pose.position.z = pz
        ps.pose.orientation.x = qx; ps.pose.orientation.y = qy; ps.pose.orientation.z = qz; ps.pose.orientation.w = qw
        self.pub.publish(ps)

def main():
    rclpy.init()
    node = EETargetMarker()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

################################################################################
# END ee_target_marker.py
################################################################################


################################################################################
# BEGIN ik_node.py
################################################################################

# Map joint name -> ROS topic used by your Gazebo bridge
BRIDGE_TOPICS = {
    "arm_base_joint": "/arm/arm_base_joint/cmd_pos",
    "arm_shoulder_joint": "/arm/arm_shoulder_joint/cmd_pos",
    "arm_elbow_joint": "/arm/arm_elbow_joint/cmd_pos",
    "arm_wrist_joint": "/arm/arm_wrist_joint/cmd_pos",
    "arm_gripper_base_joint": "/arm/arm_gripper_base_joint/cmd_pos",
    # Fingers exist too, but are not driven by IK:
    # "arm_gripper_left_joint": "/arm/arm_gripper_left_joint/cmd_pos",
    # "arm_gripper_right_joint": "/arm/arm_gripper_right_joint/cmd_pos",
}

class IKBridgeNode(Node):
    def __init__(self):
        super().__init__('ik_bridge_node')
        self.sub = self.create_subscription(PoseStamped, 'ee_target', self.cb, 10)
        self.pubs = {name: self.create_publisher(Float64, topic, 10) for name, topic in BRIDGE_TOPICS.items()}
        self.q = np.zeros(len(CHAIN_JOINTS))
        self.get_logger().info(f"IK Bridge ready. Driving topics via Gazebo bridge. Joints: {CHAIN_JOINTS}")
        self._last_log = self.get_clock().now()

    def cb(self, msg: PoseStamped):
        t = msg.pose.position
        q = msg.pose.orientation
        target_pos = np.array([t.x, t.y, t.z])
        target_quat = np.array([q.x, q.y, q.z, q.w])

        # Use 6D solver if available; otherwise ik_solve_se3 should resolve gracefully
        q_sol, p_sol, _ = ik_solve_se3(target_pos, target_quat, q0=self.q)
        self.q = q_sol

        # Publish each joint angle to its Float64 topic
        for name, angle in zip(CHAIN_JOINTS, q_sol.tolist()):
            if name in self.pubs:
                msg = Float64()
                msg.data = float(angle)
                self.pubs[name].publish(msg)

        now = self.get_clock().now()
        if (now - self._last_log).nanoseconds > 5e8:
            pos_err = float(np.linalg.norm(target_pos - p_sol))
            self.get_logger().info(f"cmd sent. pos_err={pos_err:.4f} m")
            self._last_log = now

def main():
    rclpy.init()
    marker = EETargetMarker()
    ik = IKBridgeNode()
    executor = MultiThreadedExecutor()
    executor.add_node(marker)
    executor.add_node(ik)
    try:
        executor.spin()
    finally:
        executor.shutdown()
        marker.destroy_node()
        ik.destroy_node()
        rclpy.shutdown()

################################################################################
# END ik_node.py
################################################################################


if __name__ == '__main__':

    main()
