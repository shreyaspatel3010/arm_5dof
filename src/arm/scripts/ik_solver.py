# Autogenerated 6D IK (position + orientation) using damped least squares
# Chain joints derived from URDF: ['arm_base_joint', 'arm_shoulder_joint', 'arm_elbow_joint', 'arm_wrist_joint', 'arm_gripper_base_joint']
import math, numpy as np

CHAIN_JOINTS = ['arm_base_joint', 'arm_shoulder_joint', 'arm_elbow_joint', 'arm_wrist_joint', 'arm_gripper_base_joint']
JOINTS = {'arm_base_joint': {'lower': -3.14, 'upper': 3.14, 'axis': [0.0, 0.0, 1.0]}, 'arm_shoulder_joint': {'lower': -1.918, 'upper': 1.918, 'axis': [1.0, 0.0, 0.0]}, 'arm_elbow_joint': {'lower': -1.748, 'upper': 1.748, 'axis': [1.0, 0.0, 0.0]}, 'arm_wrist_joint': {'lower': -1.942, 'upper': 1.942, 'axis': [1.0, 0.0, 0.0]}, 'arm_gripper_base_joint': {'lower': -1.57, 'upper': 1.57, 'axis': [0.0, 0.0, 1.0]}}
ORIGINS = {'arm_base_joint': {'xyz': [0.0, 0.0, 0.0], 'rpy': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}, 'arm_shoulder_joint': {'xyz': [0.0, 0.0, 0.2104], 'rpy': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}, 'arm_elbow_joint': {'xyz': [0.0, 0.0, 0.4186], 'rpy': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}, 'arm_wrist_joint': {'xyz': [0.0, 0.0, 0.4159], 'rpy': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}, 'arm_gripper_base_joint': {'xyz': [0.05655, 0.0, 0.1025], 'rpy': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}}

def hat(v):
    return np.array([[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]])

def axis_angle_rot(axis, theta):
    axis = np.array(axis, dtype=float)
    n = np.linalg.norm(axis)
    if n < 1e-12:
        return np.eye(3)
    axis = axis / n
    K = hat(axis)
    return np.eye(3) + math.sin(theta)*K + (1-math.cos(theta))*(K@K)

def quat_to_rot(q):
    x,y,z,w = q
    # normalize
    n = math.sqrt(x*x+y*y+z*z+w*w)
    if n < 1e-12: 
        return np.eye(3)
    x,y,z,w = x/n, y/n, z/n, w/n
    xx,yy,zz = x*x, y*y, z*z
    xy,xz,yz = x*y, x*z, y*z
    wx,wy,wz = w*x, w*y, w*z
    return np.array([
        [1-2*(yy+zz), 2*(xy - wz), 2*(xz + wy)],
        [2*(xy + wz), 1-2*(xx+zz), 2*(yz - wx)],
        [2*(xz - wy), 2*(yz + wx), 1-2*(xx+yy)]
    ])

def rot_log(R):
    # returns rotation vector (axis * angle)
    tr = (np.trace(R)-1)/2.0
    tr = max(min(tr, 1.0), -1.0)
    th = math.acos(tr)
    if th < 1e-9:
        return np.zeros(3)
    v = np.array([R[2,1]-R[1,2], R[0,2]-R[2,0], R[1,0]-R[0,1]])/(2*math.sin(th))
    return v*th

def rpy_to_rot(r,p,y):
    cr, sr = math.cos(r), math.sin(r)
    cp, sp = math.cos(p), math.sin(p)
    cy, sy = math.cos(y), math.sin(y)
    Rz = np.array([[cy,-sy,0],[sy,cy,0],[0,0,1]])
    Ry = np.array([[cp,0,sp],[0,1,0],[-sp,0,cp]])
    Rx = np.array([[1,0,0],[0,cr,-sr],[0,sr,cr]])
    return Rz @ Ry @ Rx

def fk(q):
    R = np.eye(3); p = np.zeros(3)
    for qi, name in zip(q, CHAIN_JOINTS):
        o = ORIGINS[name]
        p = p + R @ np.array(o["xyz"])
        R = R @ np.array(o["rpy"])
        j = JOINTS[name]
        if np.linalg.norm(j["axis"])>0:
            R = R @ axis_angle_rot(np.array(j["axis"]), qi)
    return R, p

def fk_pose(q):
    R,p = fk(q)
    return R, p

def jacobian_6d(q, eps=1e-6):
    # numeric 6xN jacobian [dp; dtheta]
    q = np.array(q, dtype=float)
    R0, p0 = fk_pose(q)
    J = np.zeros((6, len(q)))
    for i in range(len(q)):
        dq = q.copy(); dq[i] += eps
        R1, p1 = fk_pose(dq)
        dp = (p1 - p0)/eps
        dR = R1 @ R0.T
        dtheta = rot_log(dR)/eps
        J[:3,i] = dp
        J[3:,i] = dtheta
    return J

def clamp(q):
    out = []
    for qi, name in zip(q, CHAIN_JOINTS):
        lo, hi = JOINTS[name]["lower"], JOINTS[name]["upper"]
        if not np.isfinite(lo): lo = -1e6
        if not np.isfinite(hi): hi =  1e6
        out.append(min(max(qi, lo), hi))
    return np.array(out)

def ik_solve_se3(target_pos, target_quat, q0=None, iters=250, damping=1e-2, w_pos=1.0, w_rot=1.0, tol_pos=1e-4, tol_rot=1e-3):
    # target_quat = (x,y,z,w)
    q = np.zeros(len(CHAIN_JOINTS)) if q0 is None else np.array(q0, dtype=float).copy()
    Rd = quat_to_rot(target_quat)
    for _ in range(iters):
        R, p = fk_pose(q)
        # position error
        ep = target_pos - p
        # orientation error (rotation vector of Rd * R^T)
        eR = rot_log(Rd @ R.T)
        # weighted error
        e = np.concatenate([w_pos*ep, w_rot*eR])
        if np.linalg.norm(ep) < tol_pos and np.linalg.norm(eR) < tol_rot:
            break
        J = jacobian_6d(q)
        # weight rows
        W = np.diag([w_pos,w_pos,w_pos,w_rot,w_rot,w_rot])
        JW = W @ J
        eW = W @ e
        JT = JW.T
        dq = JT @ np.linalg.inv(JW@JT + (damping**2)*np.eye(6)) @ eW
        q = clamp(q + dq)
    Rf, pf = fk_pose(q)
    return q, pf, Rf
